package da;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class DBManager {
	private PortTableModel model;
	private File xml=null;
	private ArrayList<String[]> data = new ArrayList<String[]>();
	private Logger logger = Logger.getLogger(getClass().getName());
	
	public DBManager(PortTableModel model){
		this.model=model;
		obtainSource();
	}

	public void obtainSource(){
		xml = new File("ports.xml");
		if(xml.exists())
			populateTable();			//make new thread
		else{
//			SplashScreen splash = new SplashScreen(0000);
//			splash.showSplashAndHide();
			xml = new File("service-names-port-numbers.xml");
			if(xml.exists()){
				populateTable();		//make new thread
				saveXMLFile(data);		//make new thread
			}
			else
				sourceFromScratch();
		}
	}
	
	private void sourceFromScratch(){
		downloadNewPorts();		//make new thread
		populateTable();		//make new thread
		saveXMLFile(data);		//make new thread
	}
	
	public void updateSource(){
		if(outdated())
			sourceFromScratch();
	}

	private boolean outdated(){
		boolean outdated=false;
		if(sourceLastUpdated().compareTo(siteLastUpdated())<0){
			outdated=true;
		}
		return outdated;
	}
	
	private String sourceLastUpdated(){
		XPath xpath = XPathFactory.newInstance().newXPath();
		String version = "";
		try{
			Document doc = DocumentBuilderFactory.newInstance()
			    .newDocumentBuilder().parse("service-names-port-numbers.xml");
			version = xpath.evaluate("/registry/updated", doc);
		} catch (XPathExpressionException e) {
			logger.log(Level.SEVERE, "Invalid XPath expression!",e);
		} catch (SAXException e) {
			logger.log(Level.SEVERE, "Error parsing service-names-port-numbers.xml",e);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Error processing service-names-port-numbers.xml",e);
		} catch (ParserConfigurationException e) {
			logger.log(Level.SEVERE, "Error creating DocumentBuilder which satisfies the configuration requested.",e);
		}finally{}
        return version;
	}
	
	private String siteLastUpdated(){
		String url = "http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml";
		HttpURLConnection.setFollowRedirects(false);
		HttpURLConnection con;
		long date=0;
		try {
			con = (HttpURLConnection) new URL(url).openConnection();
			date = con.getLastModified();
		} catch (MalformedURLException e) {
			logger.log(Level.SEVERE, "Invalid URL to update from!",e);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Unable to obtain 'last-updated' info from URL!",e);
		}
		SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd");
		
		return fmt.format(new Date(date));
	}
	
	private void populateTable() {
		try{
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			Document doc = builder.parse(xml);
			doc.getDocumentElement().normalize();
			NodeList nList = doc.getElementsByTagName("record");
		    String[] record = null;

			for (int i = 0; i < nList.getLength(); i++) {
			   Node nNode = nList.item(i);

			   if (nNode.getNodeType() == Node.ELEMENT_NODE) {
			      Element element = (Element) nNode;
			      record = new String[4];
			      record[0]= getTagValue("number", element);
			      record[1]= getTagValue("protocol", element);
			      record[2]= getTagValue("name", element);
			      record[3]= getTagValue("description", element);

			      data.add(record);
			   }
			}
			model.loadData(data);
			model.loadColumnNames();
		} catch (ParserConfigurationException e) {
			logger.log(Level.SEVERE, "Error creating DocumentBuilder which satisfies the configuration requested.",e);
		} catch (SAXException e) {
			logger.log(Level.SEVERE, "Error parsing service-names-port-numbers.xml",e);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Error processing service-names-port-numbers.xml",e);
		}
	}

	private String createXMLString(ArrayList<String[]> data) {
		Date today = new Date();
		SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd");
		String updated = fmt.format(today);
		String xml = "<?xml version='1.0' encoding='UTF-8'?>\n" +
					 "<registry xmlns='www.iana.org/assignments/port-numbers' id='ports'>\n\t"+
					 "<title>Parsed Ports</title>\n\t"+
					 "<updated>"+updated+"</updated>\n\t"+
					 "<parsed>"+new Date()+"</parsed>\n\t"+
					 "<note>Data obtained from www.iana.org/assignments/port-numbers</note>\n\t";

			  for (int i = 0; i < data.size(); i++){
				//Checking for ampersands and replacing
				  if(data.get(i)[3]!=null && 
					 data.get(i)[3].contains("&"))
					  	data.get(i)[3] = data.get(i)[3].substring(0
					  			,data.get(i)[3].indexOf('&')) +
						"&amp;" + data.get(i)[3].substring(data.get(i)[3].indexOf('&')+1);
				  
				  if(data.get(i)[2]!=null && 
					 data.get(i)[2].contains("&"))
						data.get(i)[2] = data.get(i)[2].substring(0,data.get(i)[2].indexOf('&')) +
						"&amp;" + data.get(i)[2].substring(data.get(i)[2].indexOf('&')+1);
				  //crash caused by 'y' in swyp if UTF-8 not enforced
				  xml+="<record>\n\t\t<number>"+data.get(i)[0]+"</number>\n\t\t"+
						  		"<protocol>"+data.get(i)[1]+"</protocol>\n\t\t"+
						  		"<name>"+data.get(i)[2]+"</name>\n\t\t"+
						  		"<description>"+data.get(i)[3]+"</description>\n\t</record>";
			  }
			  xml += "</registry>";
			  data=null;
		return xml;
	}

	private void saveXMLFile(ArrayList<String[]> data){
		String xml = createXMLString(data);
		File xmlfile= new File("ports.xml");
		//OutputStreamWriter to enable forcing UTF-8 encoding.
		OutputStreamWriter writer = null;
		try {
		    writer = new OutputStreamWriter(new FileOutputStream(xmlfile),
		    								Charset.forName("UTF-8").newEncoder());
		    writer.write(xml);
		    writer.close();
		}
		catch (IOException e) {
			logger.log(Level.SEVERE, "Error writing to ports.xml",e);
		} 
	}

	private static String getTagValue(String tag, Element eElement) {
		NodeList nlList = null;
		if(eElement.getElementsByTagName(tag).item(0)==null)
			return "";

		nlList = eElement.getElementsByTagName(tag).item(0).getChildNodes();

		Node nValue = null;
		if(nlList.getLength()>0)
			nValue = (Node) nlList.item(0);

		return nValue==null?"":nValue.getNodeValue();
	  }
	
	private void downloadNewPorts(){
		FileOutputStream fos=null;
		try {
			URL website = new URL("http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml");
		    ReadableByteChannel rbc = Channels.newChannel(website.openStream());
		    fos = new FileOutputStream("service-names-port-numbers.xml");
//			Using transferFrom() is potentially much more efficient than a simple loop that reads
//			from the source channel and writes to this channel. Many operating systems can transfer
//			bytes directly from the source channel into the filesystem cache without actually copying them.
//		    by: dfa @ http://stackoverflow.com/questions/921262/how-to-download-and-save-a-file-from-internet-using-java
			fos.getChannel().transferFrom(rbc, 0, 1 << 24);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "Error obtaining data from www.iana.org/.../service-names-port-numbers.xml",e);
		}
		finally{
				if(fos!=null)
					try {
						fos.close();
					} catch (IOException e) {
						logger.log(Level.SEVERE, "Unable to close FileOutputStream!",e);
					}
		}
			
	}
	
	public void getByPortRange(String text, String text2) {
		//make sure can't cause overflow with num length.
		//String.compareTo() as opposed to parsing int then checking
		ArrayList<String[]> data = new ArrayList<String[]>();
		if(!text.equals("") && !text2.equals("")){
			int num1 = Integer.parseInt(text);
			int num2 = Integer.parseInt(text2);
			int tmpNum1=0;
			int tmpNum2=0;
			String num ="";
			for(int i=0;i<model.getCachedData().size(); i++){
				num = model.getCachedData().get(i)[0];
				if(!num.contains("-")){
					if(!num.trim().equals(""))
						if(Integer.parseInt(num) >= num1 &&
						   Integer.parseInt(num) <= num2)
								data.add(model.getCachedData().get(i));
				}
				else{
					tmpNum1=Integer.parseInt(num.substring(0,num.indexOf('-')));
					tmpNum2=Integer.parseInt(num.substring(num.indexOf('-')));
					if(tmpNum1 >= num1 &&
					   tmpNum2 <= num2)
						if(tmpNum1 <= num2)
							data.add(model.getCachedData().get(i));
				}
			}
			model.loadData(data);
		}
		else
			JOptionPane.showMessageDialog(null, "You must enter a start and end point for range searches!");
	}

	public void getByPort(String num, boolean ranged) {
		ArrayList<String[]> data = new ArrayList<String[]>();
		Vector<String[]> target = ranged?model.getData():model.getCachedData();
		for(int i=0;i<target.size(); i++)
			if(target.get(i)[0].equals(num))
				data.add(target.get(i));
		model.loadData(data);
	}
	
	public void getByProtocol(String num, boolean ranged) {
		ArrayList<String[]> data = new ArrayList<String[]>();
		Vector<String[]> target = ranged?model.getData():model.getCachedData();
		for(int i=0;i<target.size(); i++)
			if(target.get(i)[1].equals(num))
				data.add(target.get(i));
		model.loadData(data);
	}

	public void getByName(String name, boolean ranged) {
		ArrayList<String[]> data = new ArrayList<String[]>();
		Vector<String[]> target = ranged?model.getData():model.getCachedData();
		for(int i=0;i<target.size(); i++)
			if(target.get(i)[2].equals(name))
				data.add(target.get(i));
		model.loadData(data);
	}

	public void getByDescription(String desc, boolean ranged) {
		ArrayList<String[]> data = new ArrayList<String[]>();
		Vector<String[]> target = ranged?model.getData():model.getCachedData();
		for(int i=0;i<target.size(); i++)
			if(target.get(i)[3].contains(desc))
				data.add(target.get(i));
		model.loadData(data);
	}
	
	public void showAllPorts() {
		model.showAllData();
	}
}